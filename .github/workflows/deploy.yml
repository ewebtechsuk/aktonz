name: Deploy to Hostinger

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      reason:
        description: "Reason for manual deployment"
        required: false
        default: ""
      audit:
        description: "Set to true to run remote audit only (no rsync)"
        required: false
        default: "false"
      debug_logs:
        description: "If true: after deploy curl homepage + tail logs"
        required: false
        default: "false"
      fail_on_fatal:
        description: "If true: fail when homepage shows WP critical error or HTTP >=500"
        required: false
        default: "false"
      dry_run:
        description: "If true: rsync uses --dry-run (no remote file changes)"
        required: false
        default: "false"
      toggle_debug:
        description: "Enable or disable temporary WP_DEBUG (enable|disable|none)"
        required: false
        default: "none"
      debug_minutes:
        description: "Window (minutes) WP_DEBUG stays active after enabling"
        required: false
        default: "15"
      disable_plugins:
        description: "Comma-separated plugin folder slugs to disable (by renaming) before deploy"
        required: false
        default: ""

jobs:
  deploy:
    name: Sync files to Hostinger
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Show manual trigger reason
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.reason != '' }}
        run: |
          echo "Manual deployment reason: ${{ github.event.inputs.reason }}"

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.HOSTINGER_SSH_KEY }}

      - name: Add Host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_HOST" >> ~/.ssh/known_hosts
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}

      - name: Pre-audit (inventory critical paths)
        id: pre_audit
        run: |
          echo "[audit-pre] Starting pre-audit (event=${GITHUB_EVENT_NAME} audit_input=${AUDIT_INPUT:-n/a})"
          if [ -z "$HOSTINGER_PATH" ]; then echo "[audit-pre] HOSTINGER_PATH secret missing"; exit 1; fi
          # Sanitize HOSTINGER_PATH (remove trailing CR/LF/whitespace) to avoid newline in path causing false negatives
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          if [ "$CLEAN_PATH" != "$HOSTINGER_PATH" ]; then
            echo "[audit-pre] Trimmed HOSTINGER_PATH -> '$CLEAN_PATH' (raw had trailing whitespace)"
          fi
          HOSTINGER_PATH="$CLEAN_PATH"
          # Distinguish required vs optional dirs. "core" and "storage" were previously treated as required
          # but they are not standard WordPress core directories; treat them as optional so their absence
          # doesn't inflate the missing count.
          REQUIRED_DIRS=(wp-admin wp-includes wp-content)
          OPTIONAL_DIRS=(core storage)
          EXPECT_FILES=(index.php wp-load.php)
          ssh -o BatchMode=yes -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" 'echo [remote] reachable' || { echo "[audit-pre] SSH failed"; exit 1; }
          echo "[audit-pre] Top-level contents:"; ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "ls -1A $HOSTINGER_PATH" | sed 's/^/[ls]/'
          MISS=0
          # wp-config.php may live either in the root or one directory above for mild hardening.
          # Check after initializing MISS so missing config increments properly.
          if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$HOSTINGER_PATH/wp-config.php\" ]" 2>/dev/null; then
            echo "[audit-pre] OK config: wp-config.php (root)"
          elif PARENT_DIR=$(dirname "$HOSTINGER_PATH"); ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$PARENT_DIR/wp-config.php\" ]" 2>/dev/null; then
            echo "[audit-pre] OK config: wp-config.php (parent directory)"
          else
            echo "[audit-pre] MISSING config: wp-config.php (neither root nor parent)"; MISS=$((MISS+1));
            # Fallback heuristic search to help operator correct HOSTINGER_PATH secret if mis-pointed
            BASE_DIR=$(dirname "$HOSTINGER_PATH")
            echo "[audit-pre][hint] Searching nearby directories (maxdepth 4) for wp-config.php to suggest correct path..."
            CANDIDATES=$(ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "find \"$BASE_DIR\" -maxdepth 4 -type f -name wp-config.php 2>/dev/null | sort" || true)
            if [ -n "$CANDIDATES" ]; then
              echo "$CANDIDATES" | sed 's/^/[audit-pre][hint][found] /'
              # If exactly one candidate, propose exporting as corrected path
              ONE_COUNT=$(echo "$CANDIDATES" | wc -l | tr -d ' ')
              if [ "$ONE_COUNT" = "1" ]; then
                SUGGESTED=$(dirname "$CANDIDATES")
                echo "[audit-pre][hint] Consider updating HOSTINGER_PATH secret to: $SUGGESTED"
              fi
            else
              echo "[audit-pre][hint] No wp-config.php found within 4 levels of $BASE_DIR"
            fi
          fi
          REMOTE_LIST=$(ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "ls -1A \"$HOSTINGER_PATH\"") || REMOTE_LIST=""
          printf '%s' "$REMOTE_LIST" > remote_listing.txt
          echo "[audit-pre][debug] Remote path bytes:"; printf '%s' "$HOSTINGER_PATH" | od -An -tx1 | sed 's/^/[hex]/'
          # Required directories
          for d in "${REQUIRED_DIRS[@]}"; do
            if grep -Fxq "$d" <<<"$REMOTE_LIST"; then
              echo "[audit-pre] OK dir(listing): $d"
            else
              # Fallback test directly
              if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -d \"$HOSTINGER_PATH/$d\" ]" 2>/dev/null; then
                echo "[audit-pre] OK dir(test): $d"
              else
                echo "[audit-pre] MISSING dir: $d"; MISS=$((MISS+1));
                ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "ls -ld '$HOSTINGER_PATH' || true" | sed 's/^/[audit-pre][parent]/'
              fi
            fi
          done
          # Optional directories (informational only)
          for d in "${OPTIONAL_DIRS[@]}"; do
            if grep -Fxq "$d" <<<"$REMOTE_LIST"; then
              echo "[audit-pre] OK optional dir(listing): $d"
            else
              if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -d \"$HOSTINGER_PATH/$d\" ]" 2>/dev/null; then
                echo "[audit-pre] OK optional dir(test): $d"
              else
                echo "[audit-pre] OPTIONAL dir missing (ignored): $d"
              fi
            fi
          done
          for f in "${EXPECT_FILES[@]}"; do
            if grep -Fxq "$f" <<<"$REMOTE_LIST"; then
              echo "[audit-pre] OK file(listing): $f"
            else
              if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$HOSTINGER_PATH/$f\" ]" 2>/dev/null; then
                echo "[audit-pre] OK file(test): $f"
              else
                echo "[audit-pre] MISSING file: $f"; MISS=$((MISS+1));
              fi
            fi
          done
          # Try to tail a recent PHP error log if present
          for cand in php-error.log debug.log error_log; do
            if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$HOSTINGER_PATH/wp-content/$cand\" ]"; then
              echo "[audit-pre] Tail of wp-content/$cand:"; ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "tail -n 40 '$HOSTINGER_PATH/wp-content/$cand'" | sed 's/^/[log]/'; break; fi
          done
          echo "[audit-pre] Missing count: $MISS"
          echo "missing_count=$MISS" >> $GITHUB_OUTPUT
          if [ "$MISS" -gt 0 ]; then
            echo "[audit-pre] WARNING: $MISS required path(s) missing.";
          fi
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}
          AUDIT_INPUT: ${{ github.event.inputs.audit }}

      - name: List remote plugins (debug)
        if: ${{ github.event.inputs.audit != 'true' }}
        run: |
          echo "[plugins-list] Listing remote plugin directories to verify slugs";
          ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "ls -1A \"$HOSTINGER_PATH/wp-content/plugins\" 2>/dev/null" | sed 's/^/[plugins-list]/' || echo "[plugins-list] Unable to list remote plugins"
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Prune stale LiteSpeed disabled copies (keep newest 2)
        if: ${{ github.event.inputs.audit != 'true' }}
        run: |
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          HOSTINGER_PATH="$CLEAN_PATH"
          echo "[prune] Checking for stale litespeed-cache.disabled.* directories"
          ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" bash -s <<'EOF' || true
PLUGDIR="$HOSTINGER_PATH/wp-content/plugins"
cd "$PLUGDIR" 2>/dev/null || { echo '[prune] Plugin dir missing; skip'; exit 0; }
LIST=$(ls -1d litespeed-cache.disabled.* 2>/dev/null | sort -t. -k4,4n || true)
[ -z "$LIST" ] && { echo '[prune] Nothing to prune (none found)'; exit 0; }
COUNT=$(printf '%s' "$LIST" | grep -c litespeed-cache.disabled || true)
[ -z "$COUNT" ] && COUNT=0
[ "$COUNT" -le 2 ] && { echo "[prune] Nothing to prune (count=$COUNT)"; exit 0; }
KEEP=$(printf '%s\n' "$LIST" | tail -n 2)
echo "[prune] Keeping:"; printf '%s\n' "$KEEP" | sed 's/^/[prune][keep] /'
TO_DELETE=$(comm -23 <(printf '%s\n' "$LIST") <(printf '%s\n' "$KEEP"))
echo "[prune] Deleting:"; printf '%s\n' $TO_DELETE | sed 's/^/[prune][del] /'
for d in $TO_DELETE; do rm -rf -- "$d" || echo "[prune][warn] Failed to remove $d"; done
EOF
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Disable requested plugins (rename folders)
        # Runs when not an audit; script itself checks if any list (input or secret) provided
        if: ${{ github.event.inputs.audit != 'true' }}
        run: |
          # Priority: manual workflow_dispatch input > secret fallback
            if [ -z "$DISABLE_PLUGINS_INPUT" ] && [ -z "$DISABLE_PLUGINS_SECRET" ]; then
              echo "[plugins] No disable list provided (input or secret); skipping."; exit 0;
            fi
            if [ -n "$DISABLE_PLUGINS_INPUT" ]; then
              LIST="$DISABLE_PLUGINS_INPUT"
              SOURCE="input"
            else
              LIST="$DISABLE_PLUGINS_SECRET"
              SOURCE="secret"
            fi
          echo "[plugins] Source=$SOURCE List=$LIST"
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          HOSTINGER_PATH="$CLEAN_PATH"
          IFS=',' read -r -a PLUGS <<<"$LIST"
          for p in "${PLUGS[@]}"; do
            p=$(echo "$p" | xargs) # trim whitespace
            [ -z "$p" ] && continue
            case "$p" in 
              .*|*/*) echo "[plugins] Skip invalid slug '$p'"; continue;;
            esac
            SRC="$HOSTINGER_PATH/wp-content/plugins/$p"
            DST="$SRC.disabled"
            ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "if [ -d '$SRC' ]; then if [ -d '$DST' ]; then echo '[plugins] Already disabled: $p'; else mv '$SRC' '$DST' && echo '[plugins] Disabled $p'; fi; else echo '[plugins] Not found: $p'; fi" || true
          done
        env:
          DISABLE_PLUGINS_INPUT: ${{ github.event.inputs.disable_plugins }}
          DISABLE_PLUGINS_SECRET: ${{ secrets.DISABLE_PLUGINS }}
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Neutralize cache drop-ins if LiteSpeed disabled
        if: ${{ github.event.inputs.audit != 'true' }}
        run: |
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          HOSTINGER_PATH="$CLEAN_PATH"
          # Determine if LiteSpeed plugin is disabled (directory renamed) or absent
          LSP_ORIG="$HOSTINGER_PATH/wp-content/plugins/litespeed-cache"
          LSP_DISABLED="$LSP_ORIG.disabled"
          # If plugin appears disabled, also neutralize drop-ins referencing LiteSpeed
          if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -d '$LSP_DISABLED' ]"; then
            if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -d '$LSP_ORIG' ]"; then
              TS=$(date +%s)
              echo "[dropins] Conflict: both litespeed-cache and litespeed-cache.disabled exist. Force-renaming active copy -> litespeed-cache.disabled.$TS"
              ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "mv '$LSP_ORIG' '$LSP_ORIG.disabled.$TS'" || echo "[dropins][warn] Force rename failed (permissions?)"
            fi
            echo "[dropins] LiteSpeed treated as disabled; neutralizing related drop-ins..."
            ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "if [ -f '$HOSTINGER_PATH/wp-content/object-cache.php' ] && grep -qi litespeed '$HOSTINGER_PATH/wp-content/object-cache.php'; then mv -f '$HOSTINGER_PATH/wp-content/object-cache.php' '$HOSTINGER_PATH/wp-content/object-cache.php.disabled' && echo '[dropins] Disabled object-cache.php (LiteSpeed)'; else echo '[dropins] object-cache.php absent or no LiteSpeed signature'; fi" || true
            ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "if [ -f '$HOSTINGER_PATH/wp-content/advanced-cache.php' ]; then if grep -qi litespeed '$HOSTINGER_PATH/wp-content/advanced-cache.php'; then mv -f '$HOSTINGER_PATH/wp-content/advanced-cache.php' '$HOSTINGER_PATH/wp-content/advanced-cache.php.disabled' && echo '[dropins] Renamed advanced-cache.php -> advanced-cache.php.disabled'; else echo '[dropins] advanced-cache.php present but no LiteSpeed signature'; fi; else echo '[dropins] No advanced-cache.php present'; fi" || true
          else
            echo "[dropins] LiteSpeed plugin directory not (yet) disabled; skipping drop-in neutralization (still enforcing WP_CACHE=false)."
          fi
          # Always enforce single clean WP_CACHE=false define to avoid stale caching state.
          ROOT_CFG="$HOSTINGER_PATH/wp-config.php"
          PARENT_CFG="$(dirname "$HOSTINGER_PATH")/wp-config.php"
          CFG=""
          if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f '$ROOT_CFG' ]"; then
            CFG="$ROOT_CFG"
          elif ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f '$PARENT_CFG' ]"; then
            CFG="$PARENT_CFG"
          else
            SEARCH_BASE="$(dirname "$HOSTINGER_PATH")"
            CFG=$(ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "find '$SEARCH_BASE' -maxdepth 4 -type f -name wp-config.php 2>/dev/null | head -n1" || true)
          fi
          if [ -z "$CFG" ]; then
            echo "[dropins] wp-config.php not found (cannot enforce WP_CACHE)";
          else
            echo "[dropins] Sanitizing WP_CACHE defines in: $CFG"
            # Execute remote sanitation & append via a single SSH here-doc to avoid complex local quoting
            ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" bash <<'REMOTE_WPC'
set -e
CFG="$CFG"
if [ ! -f "$CFG" ]; then echo "[dropins][remote] Config vanished mid-run"; exit 0; fi
# Remove existing WP_CACHE define lines (exclude WP_CACHE_KEY_SALT) case-insensitively
awk 'BEGIN{IGNORECASE=1} {
  if ($0 ~ /define[[:space:]]*\(/ && $0 ~ /WP_CACHE['\"']/ && $0 !~ /WP_CACHE_KEY_SALT/) next; print;
}' "$CFG" > "$CFG.ci.tmp" && mv "$CFG.ci.tmp" "$CFG"
echo "// Managed by CI: force disable page/object cache while troubleshooting" >> "$CFG"
echo "if (!defined('WP_CACHE')) { define('WP_CACHE', false); }" >> "$CFG"
grep -n "WP_CACHE" "$CFG" | sed 's/^/[dropins][cfg]/' || true
REMOTE_WPC
          fi
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Scan for residual LiteSpeed references (post-neutralization)
        if: ${{ github.event.inputs.audit != 'true' }}
        run: |
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          HOSTINGER_PATH="$CLEAN_PATH"
          echo "[scan] Checking for residual LiteSpeed strings in wp-config.php, mu-plugins, object-cache, advanced-cache"
          ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "grep -RIn -E 'LiteSpeed|litespeed' '$HOSTINGER_PATH/wp-config.php' '$HOSTINGER_PATH/wp-content/object-cache.php' '$HOSTINGER_PATH/wp-content/advanced-cache.php' '$HOSTINGER_PATH/wp-content/mu-plugins' 2>/dev/null | head -n 120" | sed 's/^/[scan]/' || echo '[scan] No references (or files missing)'
          echo "[scan] Done (showing first 120 matches if any)."
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Stop after audit (audit-only)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.audit == 'true' }}
        run: |
          echo "[audit] Audit-only run requested; skipping rsync and marker steps.";
          exit 0

      - name: Rsync to server
        if: ${{ github.event.inputs.audit != 'true' }}
        run: |
          # Base rsync excludes
          # Sanitize HOSTINGER_PATH (remove trailing CR/LF/whitespace) for consistency
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          if [ "$CLEAN_PATH" != "$HOSTINGER_PATH" ]; then
            echo "[deploy] Trimmed HOSTINGER_PATH -> '$CLEAN_PATH'"
          fi
          HOSTINGER_PATH="$CLEAN_PATH"
          RSYNC_EXCLUDES=(
            ".git" ".github" ".devcontainer" "node_modules" "vendor" "*.log" "*.sql" "wp-config-local.php" "wp-content/cache" "wp-content/litespeed" "wp-content/uploads" "wp-content/upgrade"
            "wp-content/mu-plugins.disabled" "wp-content/plugins.disabled" "wp-content/plugins.off" "wp-content/themes.off"
            "aktonz-local-copy" # local backup snapshot, never deploy
          )

          # Exclude remote-only or dynamically generated directories that are not tracked in the repo but required in production.
          # These paths existed on production (e.g. asset/CSS generation or custom platform code) and were likely removed by --delete, causing homepage fatal errors.
          RSYNC_EXCLUDES+=("core" "storage")
          
          # Guard: detect ONLY top-level accidental self-nested duplicate directories (./name/name) to exclude
          # This avoids excluding legitimate vendor paths like twig/twig inside plugins.
          SELF_NESTED=$(find . -maxdepth 2 -mindepth 2 -type d -regextype posix-extended -regex './([^/]+)/\1$' | sed 's#^./##' | grep -v '^.git' || true)
          if [ -n "$SELF_NESTED" ]; then
            echo "[guard] Detected top-level self-nested duplicate directories; excluding from deployment:" 
            echo "$SELF_NESTED" | sed 's/^/  - /'
            while IFS= read -r d; do
              RSYNC_EXCLUDES+=("$d")
            done <<< "$SELF_NESTED"
          fi

          # Extra safety: never deploy nested aktonz-local-copy copies
          RSYNC_EXCLUDES+=("aktonz-local-copy/aktonz-local-copy")
          EXCLUDE_ARGS=""; for e in "${RSYNC_EXCLUDES[@]}"; do EXCLUDE_ARGS+=" --exclude=$e"; done
          echo "[deploy] Connectivity test (nc)..." || true
          command -v nc >/dev/null && nc -vz -w5 "$HOSTINGER_SSH_HOST" "$HOSTINGER_SSH_PORT" || echo "[warn] nc not available or port check failed (may still work)"
          echo "[deploy] Connectivity test (ssh banner)..." || true
          ssh -o BatchMode=yes -o ConnectTimeout=10 -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" 'echo [remote] ssh ok' || { echo "[error] SSH connection failed. Verify HOSTINGER_* secrets, firewall, and that the key is installed."; exit 1; }
          echo "[deploy] Starting rsync..." 
          # Make --delete optional to avoid wiping remote-only directories (like core/, storage/) by default.
          # Enable deletion only if DELETE_REMOTE is explicitly set to 'true'.
          DELETE_FLAG=""
          if [ "${DELETE_REMOTE:-false}" = "true" ]; then
            DELETE_FLAG="--delete"
            echo "[deploy] Remote deletion enabled (--delete)."
          else
            echo "[deploy] Remote deletion disabled (safer sync). Set secret DELETE_REMOTE=true to enable."
          fi
          rsync -az -e "ssh -p $HOSTINGER_SSH_PORT" $DELETE_FLAG $EXCLUDE_ARGS ./ "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST:$HOSTINGER_PATH" || { echo "[error] rsync failed"; exit 1; }
          if [ "${DRY_RUN_INPUT}" = "true" ]; then
            echo "[deploy] NOTE: This was a dry run; no remote changes were applied."
          fi
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}
          DELETE_REMOTE: ${{ secrets.DELETE_REMOTE }}
          DRY_RUN_INPUT: ${{ github.event.inputs.dry_run }}

      - name: Optional - Run WP cache flush
        if: ${{ success() && env.RUN_WP_CLI_CACHE_FLUSH == 'true' && github.event.inputs.audit != 'true' }}
        run: |
          ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "cd $HOSTINGER_PATH && wp cache flush || true"
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}
          RUN_WP_CLI_CACHE_FLUSH: ${{ secrets.RUN_WP_CLI_CACHE_FLUSH || 'false' }}

      - name: Record deployment marker
        if: ${{ success() && github.event.inputs.audit != 'true' }}
        run: |
          echo "[deploy] Writing .deploy-info.json marker with commit $GITHUB_SHA" 
          if [ -z "$HOSTINGER_PATH" ]; then
            echo "[error] HOSTINGER_PATH not set"; exit 1;
          fi
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          HOSTINGER_PATH="$CLEAN_PATH"
          COMMIT="$GITHUB_SHA"
            STAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          JSON=$(printf '{"commit":"%s","deployed_at":"%s","source":"github_actions"}' "$COMMIT" "$STAMP")
          REMOTE_DIR="${HOSTINGER_PATH%/}"
          echo "[deploy] Remote dir (length $(printf '%s' "$REMOTE_DIR" | wc -c))"
          printf '%s' "$JSON" | sha256sum | awk '{print "[deploy] Marker sha256 " $1}'
          # Create directory then stream JSON via stdin to avoid quoting issues
          printf '%s' "$JSON" | ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "mkdir -p \"$REMOTE_DIR\" && cat > \"$REMOTE_DIR/.deploy-info.json\"" \
            || { echo '[error] Failed to stream marker to remote'; exit 1; }
          # Verify marker on remote
          ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "test -s \"$REMOTE_DIR/.deploy-info.json\" && head -c 200 \"$REMOTE_DIR/.deploy-info.json\"" | sed 's/^/[marker]/' || { echo '[error] Remote marker verification failed'; exit 1; }
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Toggle WP_DEBUG (optional)
        if: ${{ success() && github.event.inputs.audit != 'true' && github.event.inputs.toggle_debug != 'none' && github.event.inputs.toggle_debug != '' }}
        run: |
          ACTION="${TOGGLE_DEBUG}"
          MINUTES="${DEBUG_MINUTES}"
          if ! echo "$MINUTES" | grep -Eq '^[0-9]+$'; then MINUTES=15; fi
          if [ "$MINUTES" -lt 1 ]; then MINUTES=15; fi
          CONFIG_ROOT="$HOSTINGER_PATH/wp-config.php"
          CONFIG_PARENT="$(dirname "$HOSTINGER_PATH")/wp-config.php"
          if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$CONFIG_ROOT\" ]"; then
            TARGET="$CONFIG_ROOT"
          elif ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$CONFIG_PARENT\" ]"; then
            TARGET="$CONFIG_PARENT"
          else
            echo "[debug-toggle] wp-config.php not found in root or parent; attempting heuristic search...";
            BASE_DIR=$(dirname "$HOSTINGER_PATH")
            CAND=$(ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "find \"$BASE_DIR\" -maxdepth 4 -type f -name wp-config.php 2>/dev/null | head -n 1" || true)
            if [ -n "$CAND" ]; then
              TARGET="$CAND"
              echo "[debug-toggle] Using discovered config: $TARGET"
            else
              echo "[debug-toggle] No wp-config.php discovered by search; skipping."; exit 0
            fi
          fi
          echo "[debug-toggle] Target config: $TARGET (action=$ACTION minutes=$MINUTES)"
          if [ "$ACTION" = "enable" ]; then
            ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" bash -c "'set -e
              TMP=\"$TARGET.copilot.tmp\"
              if grep -q COPILOT_DEBUG_START \"$TARGET\"; then
                echo \"[remote] Updating existing debug window to $MINUTES min\";
                # Replace window line
                sed -E -i \"s/(COPILOT_DEBUG_WINDOW *= *)[0-9]+/\\1$MINUTES/\" \"$TARGET\"
              else
                echo \"[remote] Inserting temporary debug snippet ($MINUTES min)\";
                awk -v M=$MINUTES '
                  /require_once[[:space:]]+ABSPATH.*wp-settings.php/ {
                    print "// COPILOT_DEBUG_START";
                    print "// Auto-inserted by CI for temporary debug window";
                    print "if (!defined(\\"WP_DEBUG\\")) {";
                    print "  $COPILOT_DEBUG_WINDOW = " M "; // COPILOT_DEBUG_WINDOW";
                    print "  $__flag = __DIR__ . \\\"/wp-content/.copilot_debug_start\\\";";
                    print "  if (!file_exists($__flag)) { @file_put_contents($__flag, time()); }";
                    print "  $__started = (int) @file_get_contents($__flag);";
                    print "  if ($__started + ($COPILOT_DEBUG_WINDOW * 60) > time()) {";
                    print "    define(\\"WP_DEBUG\\", true);";
                    print "    define(\\"WP_DEBUG_LOG\\", true);";
                    print "    define(\\"WP_DEBUG_DISPLAY\\", false);";
                    print "  }";
                    print "}";
                    print "// COPILOT_DEBUG_END";
                  }
                  { print }' "$TARGET" > "$TMP" && mv "$TMP" "$TARGET"
              fi
            '"
          elif [ "$ACTION" = "disable" ]; then
            ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" bash -c "'set -e
              if grep -q COPILOT_DEBUG_START \"$TARGET\"; then
                echo \"[remote] Removing debug snippet\";
                sed -i '/COPILOT_DEBUG_START/,/COPILOT_DEBUG_END/d' \"$TARGET\"
              else
                echo \"[remote] No debug snippet present\";
              fi
              # Remove timer file
              rm -f \"$HOSTINGER_PATH/wp-content/.copilot_debug_start\" 2>/dev/null || true
            '"
          else
            echo "[debug-toggle] Unrecognized action: $ACTION"; exit 1
          fi
        env:
          TOGGLE_DEBUG: ${{ github.event.inputs.toggle_debug }}
          DEBUG_MINUTES: ${{ github.event.inputs.debug_minutes }}
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}

      - name: Post-deploy health check (optional)
        if: ${{ success() && env.PRODUCTION_URL != '' && github.event.inputs.audit != 'true' }}
        run: |
          PATH_PART="${HEALTHCHECK_PATH:-/}"
          # Ensure path part starts with /
          case "$PATH_PART" in
            /*) : ;;
            *) PATH_PART="/$PATH_PART" ;;
          esac
          URL="${PRODUCTION_URL%/}$PATH_PART"
          echo "[deploy] Health check: $URL" 
          curl -I -L --max-time 20 --retry 2 --retry-delay 3 "$URL" | sed 's/^/[health]/' || { echo '[error] Health check failed'; exit 1; }
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
          HEALTHCHECK_PATH: ${{ secrets.HEALTHCHECK_PATH }}

      - name: Runtime probe & log tail (optional)
        if: ${{ success() && github.event.inputs.audit != 'true' && github.event.inputs.debug_logs == 'true' }}
        run: |
          if [ -z "$PRODUCTION_URL" ]; then echo "[runtime] PRODUCTION_URL not set; skipping curl."; exit 0; fi
          URL="${PRODUCTION_URL%/}/"
          echo "[runtime] Probing homepage: $URL"
          # Capture body & headers
          curl -s -S -D headers.txt -o body.html -w '%{http_code}' "$URL" > status_code.txt || true
          SC=$(cat status_code.txt)
          echo "[runtime] HTTP status: $SC"; echo "[runtime] --- Headers ---"; sed 's/^/[hdr]/' headers.txt | head -n 40
          echo "[runtime] --- Body (first 80 lines) ---"; nl -ba body.html | sed 's/^/[body]/' | head -n 80
          # Tail candidate logs
          for cand in debug.log php-error.log error_log; do
            if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -f \"$HOSTINGER_PATH/wp-content/$cand\" ]"; then
              echo "[runtime] Tail of wp-content/$cand"; ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "tail -n 60 '$HOSTINGER_PATH/wp-content/$cand'" | sed 's/^/[log]/'
            fi
          done
          FAIL=0
          if [ "${FAIL_ON_FATAL}" = "true" ]; then
            if [ "$SC" -ge 500 ] || grep -qi 'critical error' body.html; then
              echo "[runtime] Detected fatal indicator (status $SC or body contains 'critical error')."
              FAIL=1
            fi
          fi
          if [ $FAIL -eq 1 ]; then
            echo "[runtime] Failing job due to fatal detection."; exit 1; fi
        env:
          PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }}
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}
          FAIL_ON_FATAL: ${{ github.event.inputs.fail_on_fatal }}

      - name: Post-audit (verify after sync)
        if: ${{ success() && github.event.inputs.audit != 'true' }}
        run: |
          echo "[audit-post] Verifying critical directories after deployment"
          CLEAN_PATH=$(printf '%s' "$HOSTINGER_PATH" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          HOSTINGER_PATH="$CLEAN_PATH"
          REQUIRED_DIRS=(wp-admin wp-includes wp-content)
            OPTIONAL_DIRS=(core storage)
          MISS=0
          REMOTE_LIST=$(ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "ls -1A \"$HOSTINGER_PATH\"") || REMOTE_LIST=""
          for d in "${REQUIRED_DIRS[@]}"; do
            if grep -Fxq "$d" <<<"$REMOTE_LIST"; then
              echo "[audit-post] OK dir(listing): $d"
            else
              if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -d \"$HOSTINGER_PATH/$d\" ]" 2>/dev/null; then
                echo "[audit-post] OK dir(test): $d"
              else
                echo "[audit-post] MISSING dir: $d"; MISS=$((MISS+1)); fi
            fi
          done
          for d in "${OPTIONAL_DIRS[@]}"; do
            if grep -Fxq "$d" <<<"$REMOTE_LIST"; then
              echo "[audit-post] OK optional dir(listing): $d"
            else
              if ssh -p "$HOSTINGER_SSH_PORT" "$HOSTINGER_SSH_USER@$HOSTINGER_SSH_HOST" "[ -d \"$HOSTINGER_PATH/$d\" ]" 2>/dev/null; then
                echo "[audit-post] OK optional dir(test): $d"
              else
                echo "[audit-post] OPTIONAL dir missing (ignored): $d"; fi
            fi
          done
          if [ "$MISS" -gt 0 ]; then
            echo "[audit-post] WARNING: $MISS required directory(ies) missing. Restore from backup before enabling delete."; fi
        env:
          HOSTINGER_SSH_HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          HOSTINGER_SSH_USER: ${{ secrets.HOSTINGER_SSH_USER }}
          HOSTINGER_SSH_PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          HOSTINGER_PATH: ${{ secrets.HOSTINGER_PATH }}
