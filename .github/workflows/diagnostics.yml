name: diagnostics

on:
  workflow_dispatch:
    inputs:
      depth:
        description: "Log lines to tail (default 200)"
        required: false
        default: "200"
      endpoints:
        description: "Comma-separated endpoints to curl (default: /,/wp-admin/,/wp-json/)"
        required: false
        default: "/,/wp-admin/,/wp-json/"
      debug:
        description: "Enable WP_DEBUG temporarily (true/false)"
        required: false
        default: "false"
      safe_mode:
        description: "Activate temporary safe mode (true/false)"
        required: false
        default: "false"
      retain_safe_mode:
        description: "If safe_mode true, leave site in safe mode after run (true/false)"
        required: false
        default: "false"
      auto_disable_litespeed:
        description: "Auto disable LiteSpeed Cache plugin if fatal signature detected (true/false)"
        required: false
        default: "true"
      force_disable_litespeed:
        description: "Force disable (rename) LiteSpeed Cache plugin regardless of signature (true/false)"
        required: false
        default: "false"
      litespeed_fatal_window_minutes:
        description: "Minutes window for considering LiteSpeed fatal signature 'fresh' (auto-disable only if within window)"
        required: false
        default: "15"
      enforce_status_check:
        description: "Fail workflow if endpoints return unexpected HTTP codes (true/false)"
        required: false
        default: "true"
      allowed_redirect_endpoints:
        description: "Comma-separated endpoints allowed to return 3xx (login redirects)"
        required: false
        default: "/wp-admin/"
      root_path_override:
        description: "(Optional) Explicit remote WP root path overriding secret (e.g. /home/USER/domains/example.com/public_html)"
        required: false
        default: ""

jobs:
  gather:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup SSH
        # Added continue-on-error to prevent post-step cleanup bug ("file argument must be of type string") from failing job
        # Disable public key logging to avoid triggering known issue in action post hook
        continue-on-error: true
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.HOSTINGER_SSH_KEY }}
          log-public-key: false
      - name: Add remote host key
        shell: bash
        env:
          HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
        run: |
          set -euo pipefail
          if [ -z "${HOST:-}" ]; then
            echo "[diag][prep] HOST secret empty; skipping host key add"; exit 0; fi
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          host_only=${HOST%%:*}
          if ssh-keygen -F "$host_only" >/dev/null 2>&1; then
            echo "[diag][prep] Host key already present for $host_only"
          else
            echo "[diag][prep] Scanning and adding host key for $host_only port ${PORT:-22}"
            ssh-keyscan -p "${PORT:-22}" -t rsa,ecdsa,ed25519 "$host_only" 2>/dev/null >> ~/.ssh/known_hosts || echo "[diag][warn] ssh-keyscan failed (continuing)"
          fi
      - name: Collect diagnostics
        env:
          HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          USER: ${{ secrets.HOSTINGER_SSH_USER }}
          PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          ROOT: ${{ github.event.inputs.root_path_override && github.event.inputs.root_path_override != '' && github.event.inputs.root_path_override || secrets.HOSTINGER_PATH }}
          DEPTH: ${{ github.event.inputs.depth }}
          EPS: ${{ github.event.inputs.endpoints }}
          DEBUG_FLAG: ${{ github.event.inputs.debug }}
          SAFE_MODE: ${{ github.event.inputs.safe_mode }}
          RETAIN_SAFE_MODE: ${{ github.event.inputs.retain_safe_mode }}
          AUTO_DISABLE_LSCACHE: ${{ github.event.inputs.auto_disable_litespeed }}
          FORCE_DISABLE_LSCACHE: ${{ github.event.inputs.force_disable_litespeed }}
          FATAL_WINDOW_MIN: ${{ github.event.inputs.litespeed_fatal_window_minutes }}
          ENFORCE_STATUS_CHECK: ${{ github.event.inputs.enforce_status_check }}
          ALLOWED_REDIRECT_ENDPOINTS: ${{ github.event.inputs.allowed_redirect_endpoints }}
          PROD_URL: ${{ secrets.PRODUCTION_URL }}
        shell: bash
        run: |
          set -euo pipefail
          DEPTH=${DEPTH:-200}
          ROOT=$(printf '%s' "$ROOT" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          echo "[diag] Root=$ROOT depth=$DEPTH debug=$DEBUG_FLAG safe_mode=$SAFE_MODE retain=$RETAIN_SAFE_MODE auto_disable_lscache=$AUTO_DISABLE_LSCACHE force_disable_lscache=$FORCE_DISABLE_LSCACHE enforce_status_check=$ENFORCE_STATUS_CHECK allowed_redirects=$ALLOWED_REDIRECT_ENDPOINTS"
          CAN_SSH=0
          if [ -n "${HOST:-}" ] && [ -n "${USER:-}" ]; then
            if ssh -o BatchMode=yes -o StrictHostKeyChecking=yes -p "$PORT" "$USER@$HOST" "echo ok" 2>/dev/null | grep -q '^ok'; then
              CAN_SSH=1
              echo "[diag] SSH connectivity verified"
            else
              echo "[diag][warn] SSH connectivity test failed (host key or auth). Remote-only data will be skipped."
            fi
          else
            echo "[diag][warn] HOST/USER not set; skipping remote capture"
          fi
          if [ "$CAN_SSH" = 1 ] && [ "${SAFE_MODE,,}" = "true" ]; then
            echo "[diag] Activating safe mode (disable plugins + default theme)"
            LOCAL_SCRIPT="safe_mode.sh"
            if [ -f "scripts/safe_mode.sh" ]; then LOCAL_SCRIPT="scripts/safe_mode.sh"; fi
            scp -P "$PORT" "$LOCAL_SCRIPT" "$USER@$HOST:$ROOT/ci-safe-mode.sh" 2>/dev/null || true
            ssh -p "$PORT" "$USER@$HOST" "chmod +x '$ROOT/ci-safe-mode.sh' && WP_PATH='$ROOT' bash '$ROOT/ci-safe-mode.sh' enable" || echo "[diag][warn] safe mode activation failed"
          fi
          if [ "$CAN_SSH" = 1 ]; then
            echo "[diag] DB connectivity test"
            ssh -p "$PORT" "$USER@$HOST" "php -r \"include '$ROOT/wp-config.php'; \\\$d=@mysqli_connect(DB_HOST, DB_USER, DB_PASSWORD, DB_NAME); if(!\\\$d){echo '[db][error] '.mysqli_connect_error().\\\"\\n\\\";} else {echo '[db] connect ok\\n'; mysqli_close(\\\$d);} \"" 2>/dev/null || echo "[diag][warn] DB test command failed"
            CFG="$ROOT/wp-config.php"
            if ssh -p "$PORT" "$USER@$HOST" "[ -f '$CFG' ]"; then
              echo "[diag] wp-config.php head (20)"; ssh -p "$PORT" "$USER@$HOST" "head -n 20 '$CFG'" | sed 's/^/[cfg][head]/'
              echo "[diag] wp-config.php WP_CACHE lines"; ssh -p "$PORT" "$USER@$HOST" "grep -n -i WP_CACHE '$CFG' 2>/dev/null" | sed 's/^/[cfg][cache]/' || true
            else
              echo "[diag][warn] wp-config.php not found"
            fi
            if [ "${DEBUG_FLAG,,}" = "true" ]; then
              echo "[diag] Enabling runtime WP_DEBUG via mu-plugin"
              MU_DIR="$ROOT/wp-content/mu-plugins"; TMP="ci-debug-diag.php";
              ssh -p "$PORT" "$USER@$HOST" "mkdir -p '$MU_DIR'"
              printf "%s\n" "<?php" \
                "if (!defined('WP_DEBUG')) define('WP_DEBUG', true);" \
                "if (!defined('WP_DEBUG_LOG')) define('WP_DEBUG_LOG', true);" \
                "if (!defined('WP_DEBUG_DISPLAY')) define('WP_DEBUG_DISPLAY', false);" \
                "error_log('[ci-diag] temporary debug mu-plugin active');" > "$TMP"
              scp -P "$PORT" "$TMP" "$USER@$HOST:$MU_DIR/zzz-ci-diag-debug.php" 2>/dev/null || true
              rm -f "$TMP"
            fi
          fi
          # Early LiteSpeed force & fatal signature detection & auto-disable (before curls)
          LSCACHE_AUTO_DISABLED=0
          LSCACHE_RECENT_FATAL=0
          if [ "$CAN_SSH" = 1 ] && [ "${FORCE_DISABLE_LSCACHE,,}" = "true" ]; then
            echo "[diag][auto][force] Force disabling LiteSpeed Cache plugin"
            ssh -p "$PORT" "$USER@$HOST" "if [ -d '$ROOT/wp-content/plugins/litespeed-cache' ]; then mv '$ROOT/wp-content/plugins/litespeed-cache' '$ROOT/wp-content/plugins/litespeed-cache.force-disabled' 2>/dev/null || true; fi"
            LSCACHE_AUTO_DISABLED=1
          elif [ "$CAN_SSH" = 1 ]; then
            # If plugin already absent, note it
            if ! ssh -p "$PORT" "$USER@$HOST" "[ -d '$ROOT/wp-content/plugins/litespeed-cache' ]"; then
              echo "[diag][auto][info] LiteSpeed plugin directory already absent"
              LSCACHE_AUTO_DISABLED=1
            fi
          fi
          if [ "$CAN_SSH" = 1 ] && [ "${AUTO_DISABLE_LSCACHE,,}" = "true" ]; then
            # Evaluate freshness of LiteSpeed fatal (optimizer.cls.php:149) by parsing timestamp of last occurrence in debug.log
            LAST_SIG_LINE=$(ssh -p "$PORT" "$USER@$HOST" "grep 'optimizer.cls.php:149' '$ROOT/wp-content/debug.log' 2>/dev/null | tail -n 1" || true)
            if [ -n "$LAST_SIG_LINE" ]; then
              # Expected format like: [31-Aug-2025 06:12:34 UTC] PHP Fatal error ... optimizer.cls.php:149
              SIG_TS=$(printf '%s' "$LAST_SIG_LINE" | sed -n "s/^\[\([0-9][0-9]-[A-Za-z][a-z][a-z]-[0-9]\{4\} [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\) UTC\].*/\1/p")
              NOW_EPOCH=$(date -u +%s)
              # Sanitize window (digits only, default 15, min 1)
              FW=${FATAL_WINDOW_MIN:-15}
              case "$FW" in *[!0-9]*|"" ) FW=15;; esac
              if [ "$FW" -le 0 ]; then FW=15; fi
              WIN_SECS=$((FW * 60))
              FRESH=0
              AGE=-1
              if [ -n "$SIG_TS" ]; then
                SIG_EPOCH=$(date -u -d "$SIG_TS" +%s 2>/dev/null || echo 0)
                if [ "$SIG_EPOCH" -gt 0 ]; then
                  AGE=$((NOW_EPOCH - SIG_EPOCH))
                  if [ "$AGE" -le "$WIN_SECS" ]; then
                    FRESH=1
                  fi
                fi
              fi
              echo "[diag][auto][sig] last_line_age_secs=$AGE window_secs=$WIN_SECS fresh=$FRESH"
              if [ "$FRESH" = 1 ]; then
                echo "[diag][auto][pre] Recent LiteSpeed fatal signature (<=${FW}m); attempting mitigation"
                if ssh -p "$PORT" "$USER@$HOST" "command -v wp >/dev/null"; then
                  ssh -p "$PORT" "$USER@$HOST" "cd '$ROOT' && wp plugin deactivate litespeed-cache --path='$ROOT' --allow-root" || echo "[diag][auto][warn] wp-cli deactivate failed (may be DB issue)"
                fi
                ssh -p "$PORT" "$USER@$HOST" "if [ -d '$ROOT/wp-content/plugins/litespeed-cache' ]; then mv '$ROOT/wp-content/plugins/litespeed-cache' '$ROOT/wp-content/plugins/litespeed-cache.auto-disabled' 2>/dev/null || true; fi"
                LSCACHE_AUTO_DISABLED=1
                LSCACHE_RECENT_FATAL=1
              else
                echo "[diag][auto][info] LiteSpeed fatal signature present but stale (> ${FW}m); no auto-disable"
              fi
            fi
          fi
          # DB probe with latency & errno JSON
          if [ "$CAN_SSH" = 1 ]; then
            ssh -p "$PORT" "$USER@$HOST" "php -r 'include \"$ROOT/wp-config.php\"; $t0=microtime(true); $d=@mysqli_connect(DB_HOST, DB_USER, DB_PASSWORD, DB_NAME); $lat=round((microtime(true)-$t0)*1000); if(!$d){echo json_encode([\"ok\"=>false,\"latency_ms\"=>$lat,\"errno\"=>mysqli_connect_errno(),\"error\"=>mysqli_connect_error()]);} else { $ver=@mysqli_get_server_info($d); mysqli_close($d); echo json_encode([\"ok\"=>true,\"latency_ms\"=>$lat,\"errno\"=>0,\"server_info\"=>$ver]); }' 2>/dev/null" > db_probe.json || echo '{}' > db_probe.json
            echo "[diag][db_probe] $(cat db_probe.json)"
          fi
          IFS=',' read -r -a ARR <<<"${EPS:-/,/wp-admin/,/wp-json/}"
          : > diag_endpoint_codes.txt
          for ep in "${ARR[@]}"; do
            ep=$(echo "$ep" | xargs)
            [ -z "$ep" ] && continue
            URL="${PROD_URL%/}$ep"
            # Derive a filesystem-safe token for artifact filenames (replace / and ?)
            safe=$(printf '%s' "$ep" | tr '/?' '_')
            echo "[diag] Curling $ep -> $URL";
            curl -s -S -D "headers${safe}.txt" -o "body${safe}.html" -w "code=%{http_code} time_total=%{time_total} time_namelookup=%{time_namelookup} time_connect=%{time_connect} time_appconnect=%{time_appconnect} time_pretransfer=%{time_pretransfer} time_starttransfer=%{time_starttransfer} size=%{size_download}B redirects=%{num_redirects} remote_ip=%{remote_ip}\n" "$URL" > "metrics${safe}.txt" || echo "[diag][warn] curl failed $ep"
            # Build per-endpoint JSON metrics
            if [ -f "metrics${safe}.txt" ]; then
              code=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^code=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              t_total=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^time_total=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              t_name=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^time_namelookup=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              t_conn=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^time_connect=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              t_appc=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^time_appconnect=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              t_pre=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^time_pretransfer=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              t_start=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^time_starttransfer=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              sizeB=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^size=/){split($i,a,"=");gsub(/B$/,"",a[2]);print a[2]}}}' "metrics${safe}.txt")
              redirects=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^redirects=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              rip=$(awk '{for(i=1;i<=NF;i++){if($i ~ /^remote_ip=/){split($i,a,"=");print a[2]}}}' "metrics${safe}.txt")
              printf '{"endpoint":"%s","code":%s,"timings":{"namelookup":%s,"connect":%s,"appconnect":%s,"pretransfer":%s,"starttransfer":%s,"total":%s},"size_bytes":%s,"redirects":%s,"remote_ip":"%s"}' \
                "$ep" "${code:-0}" "${t_name:-0}" "${t_conn:-0}" "${t_appc:-0}" "${t_pre:-0}" "${t_start:-0}" "${t_total:-0}" "${sizeB:-0}" "${redirects:-0}" "$rip" > "diag_http_${safe}.json" 2>/dev/null || true
            fi
            head -n 60 "body${safe}.html" | sed "s/^/[diag][body${safe}]/" || true
            # Extract status code from headers file (last HTTP line if multiple redirects)
            code=$(grep -E '^HTTP/' "headers${safe}.txt" | tail -n1 | awk '{print $2}')
            echo -e "${ep}\t${code}" >> diag_endpoint_codes.txt
          done
          # If we auto-disabled LiteSpeed above, re-curl primary endpoint to see immediate effect
          if [ "$LSCACHE_AUTO_DISABLED" = 1 ]; then
            echo "[diag][auto][verify] Re-curling / after LiteSpeed disable"
            curl -s -S -D headers__auto.txt -o body__auto.html -w "\n[diag][auto][verify] code=%{http_code} time=%{time_total}s size=%{size_download}B redirects=%{num_redirects}\n" "${PROD_URL%/}/" || echo "[diag][auto][warn] curl verify failed"
            head -n 40 body__auto.html | sed 's/^/[diag][auto][body]/' || true
          fi
          echo "[diag][debug] Reached post-curl block (about to capture logs)"
          if [ "$CAN_SSH" = 1 ]; then
            for logf in debug.log php-error.log error_log fatal-requests.log; do
              if ssh -p "$PORT" "$USER@$HOST" "[ -f '$ROOT/wp-content/$logf' ]"; then
                echo "[diag] Tail $logf"; ssh -p "$PORT" "$USER@$HOST" "tail -n $DEPTH '$ROOT/wp-content/$logf'" | sed "s/^/[log:$logf]/" || true
              fi
            done
            if ssh -p "$PORT" "$USER@$HOST" "command -v php >/dev/null"; then
              echo "[diag] Active plugins option"; ssh -p "$PORT" "$USER@$HOST" "php -r 'include \"$ROOT/wp-load.php\"; echo json_encode(get_option(\"active_plugins\"));'" 2>/dev/null | sed 's/^/[active_plugins]/' || true
            fi
            # Database auth error detection summary
            DB_AUTH_ERRS=0
            if ssh -p "$PORT" "$USER@$HOST" "grep -q 'mysqli_real_connect(): (HY000/1045)' '$ROOT/wp-content/debug.log' 2>/dev/null"; then
              DB_AUTH_ERRS=$(ssh -p "$PORT" "$USER@$HOST" "grep -c 'mysqli_real_connect(): (HY000/1045)' '$ROOT/wp-content/debug.log' 2>/dev/null || echo 0)
              echo "[diag][db][warn] Detected $DB_AUTH_ERRS MySQL auth failures (HY000/1045). Check DB_HOST, DB_USER, DB_PASSWORD in wp-config.php and ensure MySQL grants (GRANT ALL ON db.* TO 'user'@'localhost' IDENTIFIED BY 'pass'; FLUSH PRIVILEGES;)."
            fi
            if [ "${SAFE_MODE,,}" = "true" ] && [ "${RETAIN_SAFE_MODE,,}" != "true" ]; then
              echo "[diag] Safe mode restore (leave site unchanged after capture)"
              ssh -p "$PORT" "$USER@$HOST" "WP_PATH='$ROOT' bash '$ROOT/ci-safe-mode.sh' disable" || echo "[diag][warn] safe mode restore failed"
            elif [ "${SAFE_MODE,,}" = "true" ] && [ "${RETAIN_SAFE_MODE,,}" = "true" ]; then
              echo "[diag] Retaining safe mode (no restore)"
            fi
            # Build human-readable and JSON summaries (simplified to avoid syntax issues)
            SUMMARY_TXT="diag_summary.txt"; SUMMARY_JSON="diag_summary.json"
            {
              echo "lscache_auto_disabled=$LSCACHE_AUTO_DISABLED"
              echo "db_auth_errors=$DB_AUTH_ERRS"
              echo "endpoints:"
              sed 's/^/  /' diag_endpoint_codes.txt
            } > "$SUMMARY_TXT"
            DB_PROBE_JSON=$(cat db_probe.json 2>/dev/null || echo '{}')
            # Derive recommendation
            RECOMMENDATION="none"
            if awk -F'\t' 'NF>=2 { if($2 != 200) bad=1 } END { if(bad) exit 0; else exit 1 }' diag_endpoint_codes.txt; then
              RECOMMENDATION="endpoints_fail"
            elif [ "$DB_AUTH_ERRS" -gt 0 ] || grep -q '"ok":false' db_probe.json 2>/dev/null || grep -q '"errno":[1-9]' db_probe.json 2>/dev/null; then
              RECOMMENDATION="review_db_auth"
            elif [ "$LSCACHE_RECENT_FATAL" = 1 ]; then
              RECOMMENDATION="recent_litespeed_fatal"
            fi
            {
              echo '{'
              echo "  \"lscache_auto_disabled\": $LSCACHE_AUTO_DISABLED,"
              echo "  \"litespeed_recent_fatal\": $LSCACHE_RECENT_FATAL,"
              echo "  \"db_auth_errors\": $DB_AUTH_ERRS,"
              echo "  \"db_probe\": $DB_PROBE_JSON,"
              echo "  \"recommendation\": \"$RECOMMENDATION\"," 
              echo "  \"endpoints\": ["
              first=1
              while IFS=$'\t' read -r ep code; do
                [ -z "$ep" ] && continue
                if [ $first -eq 0 ]; then echo ","; fi
                printf '    {"endpoint": "%s", "code": %s}' "$ep" "$code"
                first=0
              done < diag_endpoint_codes.txt
              echo
              echo "  ],"
              echo "  \"endpoint_metrics\": ["
              first=1
              while IFS=$'\t' read -r ep code; do
                [ -z "$ep" ] && continue
                safe=$(printf '%s' "$ep" | tr '/?' '_')
                if [ -f "diag_http_${safe}.json" ]; then
                  if [ $first -eq 0 ]; then echo ","; fi
                  sed 's/^/    /' "diag_http_${safe}.json"
                  first=0
                fi
              done < diag_endpoint_codes.txt
              echo
              echo "  ]"
              echo '}'
            } > "$SUMMARY_JSON"
            echo "[diag][summary] lscache_auto_disabled=$LSCACHE_AUTO_DISABLED db_auth_errors=$DB_AUTH_ERRS"
            echo "recommendation=$RECOMMENDATION" >> "$SUMMARY_TXT"
          else
            echo "[diag][info] Skipped remote log and plugin capture due to SSH unavailability"
          fi
      - name: Archive diagnostics artifacts
        uses: actions/upload-artifact@v4
        with:
          name: diagnostics-output
          path: |
            *body*.html
            *headers*.txt
            metrics*.txt
            diag_http_*.json
            diag_endpoint_codes.txt
            diag_summary.txt
            diag_summary.json
            db_probe.json
          if-no-files-found: ignore
          retention-days: 5
      - name: Evaluate endpoint status codes
        if: always()
        shell: bash
        env:
          ENFORCE_STATUS_CHECK: ${{ github.event.inputs.enforce_status_check }}
          ALLOWED_REDIRECT_ENDPOINTS: ${{ github.event.inputs.allowed_redirect_endpoints }}
        run: |
          set -euo pipefail
          if [ ! -f diag_endpoint_codes.txt ]; then echo "[eval][warn] No endpoint codes file found"; exit 0; fi
          IFS=',' read -r -a ALLOWED <<<"${ALLOWED_REDIRECT_ENDPOINTS:-}" || true
          failures=0
          while IFS=$'\t' read -r ep code; do
            [ -z "${ep}" ] && continue
            ok=0
            if [ "$code" = "200" ]; then
              ok=1
            else
              # Allow 3xx for specified endpoints
              if echo "$code" | grep -qE '^(301|302|303|307|308)$'; then
                for a in "${ALLOWED[@]}"; do
                  if [ "$ep" = "$a" ]; then ok=1; break; fi
                done
              fi
            fi
            if [ $ok -ne 1 ]; then
              echo "[eval][fail] Unexpected status $code for $ep"
              failures=$((failures+1))
            else
              echo "[eval][ok] $ep -> $code"
            fi
          done < diag_endpoint_codes.txt
          echo "[eval] failures=$failures enforce=$ENFORCE_STATUS_CHECK"
          if [ "${ENFORCE_STATUS_CHECK,,}" = "true" ] && [ $failures -gt 0 ]; then
            echo "[eval] Failing job due to unexpected endpoint statuses" >&2
            exit 1
          fi
