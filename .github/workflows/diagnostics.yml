name: diagnostics

on:
  workflow_dispatch:
    inputs:
      depth:
        description: "Log lines to tail (default 200)"
        required: false
        default: "200"
      endpoints:
        description: "Comma-separated endpoints to curl (default: /,/wp-admin/,/wp-json/)"
        required: false
        default: "/,/wp-admin/,/wp-json/"
      debug:
        description: "Enable WP_DEBUG temporarily (true/false)"
        required: false
        default: "false"
      safe_mode:
        description: "Activate temporary safe mode (true/false)"
        required: false
        default: "false"
      retain_safe_mode:
        description: "If safe_mode true, leave site in safe mode after run (true/false)"
        required: false
        default: "false"
      auto_disable_litespeed:
        description: "Auto disable LiteSpeed Cache plugin if fatal signature detected (true/false)"
        required: false
        default: "true"
      force_disable_litespeed:
        description: "Force disable (rename) LiteSpeed Cache plugin regardless of signature (true/false)"
        required: false
        default: "false"
      enforce_status_check:
        description: "Fail workflow if endpoints return unexpected HTTP codes (true/false)"
        required: false
        default: "true"
      allowed_redirect_endpoints:
        description: "Comma-separated endpoints allowed to return 3xx (login redirects)"
        required: false
        default: "/wp-admin/"
      root_path_override:
        description: "(Optional) Explicit remote WP root path overriding secret (e.g. /home/USER/domains/example.com/public_html)"
        required: false
        default: ""

jobs:
  gather:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
            ssh-private-key: ${{ secrets.HOSTINGER_SSH_KEY }}
      - name: Add remote host key
        shell: bash
        env:
          HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
        run: |
          set -euo pipefail
          if [ -z "${HOST:-}" ]; then
            echo "[diag][prep] HOST secret empty; skipping host key add"; exit 0; fi
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          host_only=${HOST%%:*}
          if ssh-keygen -F "$host_only" >/dev/null 2>&1; then
            echo "[diag][prep] Host key already present for $host_only"
          else
            echo "[diag][prep] Scanning and adding host key for $host_only port ${PORT:-22}"
            ssh-keyscan -p "${PORT:-22}" -t rsa,ecdsa,ed25519 "$host_only" 2>/dev/null >> ~/.ssh/known_hosts || echo "[diag][warn] ssh-keyscan failed (continuing)"
          fi
      - name: Collect diagnostics
        env:
          HOST: ${{ secrets.HOSTINGER_SSH_HOST }}
          USER: ${{ secrets.HOSTINGER_SSH_USER }}
          PORT: ${{ secrets.HOSTINGER_SSH_PORT }}
          ROOT: ${{ github.event.inputs.root_path_override && github.event.inputs.root_path_override != '' && github.event.inputs.root_path_override || secrets.HOSTINGER_PATH }}
          DEPTH: ${{ github.event.inputs.depth }}
          EPS: ${{ github.event.inputs.endpoints }}
          DEBUG_FLAG: ${{ github.event.inputs.debug }}
          SAFE_MODE: ${{ github.event.inputs.safe_mode }}
          RETAIN_SAFE_MODE: ${{ github.event.inputs.retain_safe_mode }}
          AUTO_DISABLE_LSCACHE: ${{ github.event.inputs.auto_disable_litespeed }}
          FORCE_DISABLE_LSCACHE: ${{ github.event.inputs.force_disable_litespeed }}
          ENFORCE_STATUS_CHECK: ${{ github.event.inputs.enforce_status_check }}
          ALLOWED_REDIRECT_ENDPOINTS: ${{ github.event.inputs.allowed_redirect_endpoints }}
          PROD_URL: ${{ secrets.PRODUCTION_URL }}
        shell: bash
        run: |
          set -euo pipefail
          DEPTH=${DEPTH:-200}
          ROOT=$(printf '%s' "$ROOT" | tr -d '\r' | sed -e 's/[[:space:]]*$//')
          echo "[diag] Root=$ROOT depth=$DEPTH debug=$DEBUG_FLAG safe_mode=$SAFE_MODE retain=$RETAIN_SAFE_MODE auto_disable_lscache=$AUTO_DISABLE_LSCACHE force_disable_lscache=$FORCE_DISABLE_LSCACHE enforce_status_check=$ENFORCE_STATUS_CHECK allowed_redirects=$ALLOWED_REDIRECT_ENDPOINTS"
          CAN_SSH=0
          if [ -n "${HOST:-}" ] && [ -n "${USER:-}" ]; then
            if ssh -o BatchMode=yes -o StrictHostKeyChecking=yes -p "$PORT" "$USER@$HOST" "echo ok" 2>/dev/null | grep -q '^ok'; then
              CAN_SSH=1
              echo "[diag] SSH connectivity verified"
            else
              echo "[diag][warn] SSH connectivity test failed (host key or auth). Remote-only data will be skipped."
            fi
          else
            echo "[diag][warn] HOST/USER not set; skipping remote capture"
          fi
          if [ "$CAN_SSH" = 1 ] && [ "${SAFE_MODE,,}" = "true" ]; then
            echo "[diag] Activating safe mode (disable plugins + default theme)"
            LOCAL_SCRIPT="safe_mode.sh"
            if [ -f "scripts/safe_mode.sh" ]; then LOCAL_SCRIPT="scripts/safe_mode.sh"; fi
            scp -P "$PORT" "$LOCAL_SCRIPT" "$USER@$HOST:$ROOT/ci-safe-mode.sh" 2>/dev/null || true
            ssh -p "$PORT" "$USER@$HOST" "chmod +x '$ROOT/ci-safe-mode.sh' && WP_PATH='$ROOT' bash '$ROOT/ci-safe-mode.sh' enable" || echo "[diag][warn] safe mode activation failed"
          fi
          if [ "$CAN_SSH" = 1 ]; then
            echo "[diag] DB connectivity test"
            ssh -p "$PORT" "$USER@$HOST" "php -r \"include '$ROOT/wp-config.php'; \\\$d=@mysqli_connect(DB_HOST, DB_USER, DB_PASSWORD, DB_NAME); if(!\\\$d){echo '[db][error] '.mysqli_connect_error().\\\"\\n\\\";} else {echo '[db] connect ok\\n'; mysqli_close(\\\$d);} \"" 2>/dev/null || echo "[diag][warn] DB test command failed"
            CFG="$ROOT/wp-config.php"
            if ssh -p "$PORT" "$USER@$HOST" "[ -f '$CFG' ]"; then
              echo "[diag] wp-config.php head (20)"; ssh -p "$PORT" "$USER@$HOST" "head -n 20 '$CFG'" | sed 's/^/[cfg][head]/'
              echo "[diag] wp-config.php WP_CACHE lines"; ssh -p "$PORT" "$USER@$HOST" "grep -n -i WP_CACHE '$CFG' 2>/dev/null" | sed 's/^/[cfg][cache]/' || true
            else
              echo "[diag][warn] wp-config.php not found"
            fi
            if [ "${DEBUG_FLAG,,}" = "true" ]; then
              echo "[diag] Enabling runtime WP_DEBUG via mu-plugin"
              MU_DIR="$ROOT/wp-content/mu-plugins"; TMP="ci-debug-diag.php";
              ssh -p "$PORT" "$USER@$HOST" "mkdir -p '$MU_DIR'"
              printf "%s\n" "<?php" \
                "if (!defined('WP_DEBUG')) define('WP_DEBUG', true);" \
                "if (!defined('WP_DEBUG_LOG')) define('WP_DEBUG_LOG', true);" \
                "if (!defined('WP_DEBUG_DISPLAY')) define('WP_DEBUG_DISPLAY', false);" \
                "error_log('[ci-diag] temporary debug mu-plugin active');" > "$TMP"
              scp -P "$PORT" "$TMP" "$USER@$HOST:$MU_DIR/zzz-ci-diag-debug.php" 2>/dev/null || true
              rm -f "$TMP"
            fi
          fi
          # Early LiteSpeed force & fatal signature detection & auto-disable (before curls)
          LSCACHE_AUTO_DISABLED=0
          if [ "$CAN_SSH" = 1 ] && [ "${FORCE_DISABLE_LSCACHE,,}" = "true" ]; then
            echo "[diag][auto][force] Force disabling LiteSpeed Cache plugin"
            ssh -p "$PORT" "$USER@$HOST" "if [ -d '$ROOT/wp-content/plugins/litespeed-cache' ]; then mv '$ROOT/wp-content/plugins/litespeed-cache' '$ROOT/wp-content/plugins/litespeed-cache.force-disabled' 2>/dev/null || true; fi"
            LSCACHE_AUTO_DISABLED=1
          fi
          if [ "$CAN_SSH" = 1 ] && [ "${AUTO_DISABLE_LSCACHE,,}" = "true" ]; then
            if ssh -p "$PORT" "$USER@$HOST" "grep -q 'optimizer.cls.php:149' '$ROOT/wp-content/debug.log' 2>/dev/null"; then
              echo "[diag][auto][pre] Detected LiteSpeed fatal signature pre-curl; attempting mitigation"
              # Try wp-cli deactivate first (may fail if DB auth failing)
              if ssh -p "$PORT" "$USER@$HOST" "command -v wp >/dev/null"; then
                ssh -p "$PORT" "$USER@$HOST" "cd '$ROOT' && wp plugin deactivate litespeed-cache --path='$ROOT' --allow-root" || echo "[diag][auto][warn] wp-cli deactivate failed (may be DB issue)"
              fi
              # Rename plugin directory if still present
              ssh -p "$PORT" "$USER@$HOST" "if [ -d '$ROOT/wp-content/plugins/litespeed-cache' ]; then mv '$ROOT/wp-content/plugins/litespeed-cache' '$ROOT/wp-content/plugins/litespeed-cache.auto-disabled' 2>/dev/null || true; fi"
              LSCACHE_AUTO_DISABLED=1
            fi
          fi
          IFS=',' read -r -a ARR <<<"${EPS:-/,/wp-admin/,/wp-json/}"
          : > diag_endpoint_codes.txt
          for ep in "${ARR[@]}"; do
            ep=$(echo "$ep" | xargs)
            [ -z "$ep" ] && continue
            URL="${PROD_URL%/}$ep"
            # Derive a filesystem-safe token for artifact filenames (replace / and ?)
            safe=$(printf '%s' "$ep" | tr '/?' '_')
            echo "[diag] Curling $ep -> $URL";
            curl -s -S -D "headers${safe}.txt" -o "body${safe}.html" -w "\n[diag] code=%{http_code} time=%{time_total}s size=%{size_download}B redirects=%{num_redirects}\n" "$URL" || echo "[diag][warn] curl failed $ep"
            head -n 60 "body${safe}.html" | sed "s/^/[diag][body${safe}]/" || true
            # Extract status code from headers file (last HTTP line if multiple redirects)
            code=$(grep -E '^HTTP/' "headers${safe}.txt" | tail -n1 | awk '{print $2}')
            echo -e "${ep}\t${code}" >> diag_endpoint_codes.txt
          done
          # If we auto-disabled LiteSpeed above, re-curl primary endpoint to see immediate effect
          if [ "$LSCACHE_AUTO_DISABLED" = 1 ]; then
            echo "[diag][auto][verify] Re-curling / after LiteSpeed disable"
            curl -s -S -D headers__auto.txt -o body__auto.html -w "\n[diag][auto][verify] code=%{http_code} time=%{time_total}s size=%{size_download}B redirects=%{num_redirects}\n" "${PROD_URL%/}/" || echo "[diag][auto][warn] curl verify failed"
            head -n 40 body__auto.html | sed 's/^/[diag][auto][body]/' || true
          fi
          echo "[diag][debug] Reached post-curl block (about to capture logs)"
          if [ "$CAN_SSH" = 1 ]; then
            for logf in debug.log php-error.log error_log fatal-requests.log; do
              if ssh -p "$PORT" "$USER@$HOST" "[ -f '$ROOT/wp-content/$logf' ]"; then
                echo "[diag] Tail $logf"; ssh -p "$PORT" "$USER@$HOST" "tail -n $DEPTH '$ROOT/wp-content/$logf'" | sed "s/^/[log:$logf]/" || true
              fi
            done
            if ssh -p "$PORT" "$USER@$HOST" "command -v php >/dev/null"; then
              echo "[diag] Active plugins option"; ssh -p "$PORT" "$USER@$HOST" "php -r 'include \"$ROOT/wp-load.php\"; echo json_encode(get_option(\"active_plugins\"));'" 2>/dev/null | sed 's/^/[active_plugins]/' || true
            fi
            # Database auth error detection summary
            DB_AUTH_ERRS=0
            if ssh -p "$PORT" "$USER@$HOST" "grep -q 'mysqli_real_connect(): (HY000/1045)' '$ROOT/wp-content/debug.log' 2>/dev/null"; then
              DB_AUTH_ERRS=$(ssh -p "$PORT" "$USER@$HOST" "grep -c 'mysqli_real_connect(): (HY000/1045)' '$ROOT/wp-content/debug.log' 2>/dev/null || echo 0)
              echo "[diag][db][warn] Detected $DB_AUTH_ERRS MySQL auth failures (HY000/1045). Check DB_HOST, DB_USER, DB_PASSWORD in wp-config.php and ensure MySQL grants (GRANT ALL ON db.* TO 'user'@'localhost' IDENTIFIED BY 'pass'; FLUSH PRIVILEGES;)."
            fi
            if [ "${SAFE_MODE,,}" = "true" ] && [ "${RETAIN_SAFE_MODE,,}" != "true" ]; then
              echo "[diag] Safe mode restore (leave site unchanged after capture)"
              ssh -p "$PORT" "$USER@$HOST" "WP_PATH='$ROOT' bash '$ROOT/ci-safe-mode.sh' disable" || echo "[diag][warn] safe mode restore failed"
            elif [ "${SAFE_MODE,,}" = "true" ] && [ "${RETAIN_SAFE_MODE,,}" = "true" ]; then
              echo "[diag] Retaining safe mode (no restore)"
            fi
            # Build human-readable and JSON summaries
            SUMMARY_TXT="diag_summary.txt"
            SUMMARY_JSON="diag_summary.json"
            {
              echo "lscache_auto_disabled=$LSCACHE_AUTO_DISABLED"
              echo "db_auth_errors=$DB_AUTH_ERRS"
              echo "endpoints:"
              cat diag_endpoint_codes.txt | sed 's/^/  /'
            } > "$SUMMARY_TXT"
            # JSON assembly (simple)
            {
              echo '{'
              echo "  \"lscache_auto_disabled\": $LSCACHE_AUTO_DISABLED,"
              echo "  \"db_auth_errors\": $DB_AUTH_ERRS,"
              echo "  \"endpoints\": ["
              awk -F"\t" 'NR>1{print ","}{printf "    {\"endpoint\": \""$1"\", \"code\": "$2"}"}' diag_endpoint_codes.txt | sed '1s/^,//'
              echo "  ]"
              echo '}'
            } > "$SUMMARY_JSON"
            echo "[diag][summary] lscache_auto_disabled=$LSCACHE_AUTO_DISABLED db_auth_errors=$DB_AUTH_ERRS"
          else
            echo "[diag][info] Skipped remote log and plugin capture due to SSH unavailability"
          fi
      - name: Archive diagnostics artifacts
        uses: actions/upload-artifact@v4
        with:
          name: diagnostics-output
          path: |
            *body*.html
            *headers*.txt
            diag_endpoint_codes.txt
            diag_summary.txt
            diag_summary.json
          if-no-files-found: ignore
          retention-days: 5
      - name: Evaluate endpoint status codes
        if: always()
        shell: bash
        env:
          ENFORCE_STATUS_CHECK: ${{ github.event.inputs.enforce_status_check }}
          ALLOWED_REDIRECT_ENDPOINTS: ${{ github.event.inputs.allowed_redirect_endpoints }}
        run: |
          set -euo pipefail
          if [ ! -f diag_endpoint_codes.txt ]; then echo "[eval][warn] No endpoint codes file found"; exit 0; fi
          IFS=',' read -r -a ALLOWED <<<"${ALLOWED_REDIRECT_ENDPOINTS:-}" || true
          failures=0
          while IFS=$'\t' read -r ep code; do
            [ -z "${ep}" ] && continue
            ok=0
            if [ "$code" = "200" ]; then
              ok=1
            else
              # Allow 3xx for specified endpoints
              if echo "$code" | grep -qE '^(301|302|303|307|308)$'; then
                for a in "${ALLOWED[@]}"; do
                  if [ "$ep" = "$a" ]; then ok=1; break; fi
                done
              fi
            fi
            if [ $ok -ne 1 ]; then
              echo "[eval][fail] Unexpected status $code for $ep"
              failures=$((failures+1))
            else
              echo "[eval][ok] $ep -> $code"
            fi
          done < diag_endpoint_codes.txt
          echo "[eval] failures=$failures enforce=$ENFORCE_STATUS_CHECK"
          if [ "${ENFORCE_STATUS_CHECK,,}" = "true" ] && [ $failures -gt 0 ]; then
            echo "[eval] Failing job due to unexpected endpoint statuses" >&2
            exit 1
          fi
